;1, 2, 3
(define (make-heap min-h left right) (list min-h left right))
(define (min-h h) (car h))
(define (left h) (car (cdr h)))
(define (right h) (car (cdr (cdr h))))

(define (pq f)
  (let ((h '())
        (size 0))
  (define (empty?)
    (if (null? h)
        #t
        #f))
  (define (insert x)
    (define (helper x h)
      (cond ((null? h) (make-heap x '() '()))
            ((f x (min-h h))
             (make-heap x
                        (right h)
                        (helper (min-h h) (left h))))
            (else
             (make-heap (min-h h)
                        (right h)
                        (helper x (left h))))))
    (begin (set! h (helper x h))
           (set! size (+ 1 size))
           h))
    (define (extract-min)
      (define (remove-top h)
        (cond ((null? h) '())
              ((null? (left h)) (right h))
              ((null? (right h)) (left h))
              ((f (min-h (right h)) (min-h (left h)))
               (make-heap (min-h (right h))
                          (left h)
                          (remove-top (right h))))
              (else
               (make-heap (min-h (left h))
                          (remove-top (left h))
                          (right h)))))
    (let ((min-value (min-h h)))
      (begin (set! h (remove-top h))
             (set! size (if (= 0 size)
                            0
                            (- size 1)))
             min-value)))
    (lambda (method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'insert) insert)
            ((eq? method 'extract-min) extract-min)
            ((eq? method 'size) (lambda () size))))))

(define (f x h)
  (if (< x h)
      #t
      #f))
(define my-heap (pq f))
((my-heap 'empty?))
((my-heap 'insert) 2)
((my-heap 'insert) 7)
((my-heap 'insert) 0)
((my-heap 'extract-min))
((my-heap 'insert) 9)
((my-heap 'size))