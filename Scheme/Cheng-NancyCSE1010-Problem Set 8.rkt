;1) Can only input real numbers (nothing like (list 0 0) just put 0
(define (apa-add lst1 lst2)
  (define (car-list lst)
    (if (null? lst)
        0
        (car lst)))
  (define (cdr-list lst)
    (if (null? lst)
        '()
        (cdr lst)))
  (define (helper carry lst1 lst2)
    (if (and (null? lst1) (null? lst2) (= 0 carry))
        '()
        (cons (modulo (+ (car-list lst1) (car-list lst2) carry) 10)
              (helper (quotient (+ (car-list lst1) (car-list lst2) carry) 10)
                      (cdr-list lst1)
                      (cdr-list lst2)))))
 (reverse (helper 0 (reverse lst1) (reverse lst2))))
(apa-add (list 3 2 6 3) (list 9 6 3))
(apa-add (list 0) (list 0))
(apa-add '() (list 3))
(apa-add (list 3 2) '())

;2)
(define (d-multiply lst n)
   (define (car-list lst)
    (if (null? lst)
        0
        (car lst)))
  (define (cdr-list lst)
    (if (null? lst)
        '()
        (cdr lst)))
   (define (helper carry lst n)
    (if (and (null? lst) (= 0 carry))
        '()
        (cons (modulo (+ (* (car-list lst) n) carry) 10)
              (helper (quotient (+ (* (car-list lst) n) carry) 10)
                      (cdr-list lst)
                      n))))
  (cond ((null? lst) '())
        ((= n 0) (list 0))
        (else (reverse (helper 0 (reverse lst) n)))))
(d-multiply (list 3 6 2) 9)
(d-multiply '(6) 0)

;3)
(define (multiply lst1 lst2)
  (define (car-list lst)
    (if (null? lst)
        0
        (car lst)))
  (define (cdr-list lst)
    (if (null? lst)
        0
        (cdr lst)))
  (define (helper-mult lst1 lst2 carry)
    (cond ((and (null? lst1) (null? lst2) (= carry 0)) '())
          ((null? lst2) '())
          (else (cons (d-multiply lst1 (car lst2))
                      (helper-mult lst1 (cdr lst2) carry)))))
    (cond ((or (null? lst1) (null? lst2)) '())
          ((or (= (car lst1) 0) (= (car lst2) 0)) (list 0))
          (else 
           (let ((rows (reverse (helper-mult lst1 (reverse lst2) 0))))
             (apa-add (car (cdr rows)) (append (car rows) (list 0)))))))
(multiply (list 3 6 2 1 2) (list 3 9))
(multiply '(6 9) '())

;4)
(define (make-tree root left right) (list root left right))
(define (root t) (car t))
(define (left t) (cadr t))
(define (right t) (caddr t))
(define (rotate-right t)
  (cond ((null? t) '())
        (else (make-tree (root (left t))
                         (left (left t))
                         (make-tree (root t) (right (left t)) (right t))))))
(rotate-right (make-tree 5 (list 3 (list 1 (list 0 '() '()) '()) (list 4 '() '())) (list 7 (list 6 '() '()) (list 9 '() '()))))

(define (rotate-left t)
  (cond ((null? t) '())
        (else (make-tree (root (right t))
                         (make-tree (root t) (left t) (left (right t)))
                         (right (right t))))))
(rotate-left (make-tree 5 (list 3 (list 1 (list 0 '() '()) '()) (list 4 '() '())) (list 7 (list 6 '() '()) (list 9 '() '()))))

(define (depth t)
  (cond ((or (null? t) (not (pair? t))) 0)
        ((max (+ 1 (depth (car t))) (depth (cdr t))))))

(depth (make-tree 3 (list 1 (list 5 '() '()) (list 2 '() '())) '()))

(define (tree-repair t)
  (cond ((> (depth (left t)) (+ (depth (right t))))
         (tree-repair (rotate-right t)))
        ((< (depth (right t)) (+ (depth (left t))))
         (tree-repair (rotate-left t)))
        (else t)))
(tree-repair (make-tree 8 (list 6 (list 5 (list 4 (list 3 (list 2 (list 1 (list 0 '() '()) '()) '()) '()) '()) '()) (list 7 '() '())) (list 9 '() '())))

;5)
(define (make-heap min left right) (list min left right))
(define (h-min h) (car h))
(define (left h) (cadr h))
(define (right h) (caddr h))
(define (h-insert h n)
  (cond ((null? h) (make-heap n '() '()))
        ((< n (h-min h))
         (make-heap n (right h) (h-insert (left h) (h-min h))))
        (else
         (make-heap (h-min h) (right h) (h-insert (left h) n)))))

(define (insert-list h l)
  (if (null? l)
      h
      (insert-list (h-insert h (car l)) (cdr l))))

(define (extract-min h)
  (define (remove-top h)
    (cond ((null? h) '())
          ((null? (left h)) (right h))
          ((null? (right h)) (left h))
          ((> (h-min (left h)) (h-min (right h)))
           (make-heap (h-min (right h)) (left h) (remove-top (right h))))
          (else
           (make-heap (h-min (left h)) (remove-top (left h)) (right h)))))
  (cons (h-min h) (remove-top h)))

(define (extract-sorted h)
  (if (null? h)
      '()
      (cons (car (extract-min h)) (extract-sorted (cdr (extract-min h))))))
(extract-sorted (make-heap 3 (list 8 '() '()) (list 9 '() '())))

(define (sort-lst lst)
  (define (min lst)
    (if (null? lst)
        '()
    (car (extract-min (insert-list '() lst)))))
  (if (null? lst)
      '()
      (cons (min lst) (extract-sorted (cdr (extract-min (insert-list '() lst)))))))
(sort-lst (list 9 4 3 0 7 2))