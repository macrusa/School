#lang racket
(require racket/draw)
;1)
;quotient and modulo from problem set 8
(define (object)
  (let ((x (list 0))
        (sign #t))
    (define (increment)
      (define (apa-add-reverse n)
        (define (rem-digits digs)
          (if (null? digs) '() (cdr digs)))
        (define (apa-add-helper p1 p2 carry)
          (if (and (null? p1) (null? p2) (= 0 carry))
              '()
              (let* ((d1 (if (null? p1) 0 (car p1)))
                     (d2 (if (null? p2) 0 (car p2)))
                     (total (+ carry d1 d2)))
                (cons (modulo total 10)
                      (apa-add-helper (rem-digits p1) 
                                      (rem-digits p2) 
                                      (quotient total 10))))))
        (apa-add-helper n (list 1) 0))
      (define (apa-add n)
        (reverse (apa-add-reverse (reverse n))))
      (begin (set! x (apa-add x))
             (set! sign (if (> (car x) 0)
                            #t
                            #f))
             (cons x sign)))
    (define (decrement)
      (define (helper x)
        (if (null? x)
            '()
            (cons (- (car (reverse x)) 1) (cdr (reverse x)))))
      (begin (set! x (reverse (helper x)))
             (set! sign (if (> (car (reverse x)) 0)
                            #t
                            #f))
             (cons x sign)))
    (define (power-up)
      (define (up-helper x)
        (cond ((= 0 (car x)) 0)
              ((null? x) '())
              (else (append x (list 0)))))
      (begin (set! x (up-helper x))
             (cons x sign)))
    (define (power-down)
      (define (delete-last lst)
        (if (null? (cdr lst))
            '()
            (cons (car lst) (delete-last (cdr lst)))))
      (define (down-helper x)
            (cond ((null? x) '())
                  ((= 0 (car x)) 0)
                  ((= 1 (length x)) 0)
                  (else (delete-last x))))
      (begin (set! x (down-helper x))
             (cons x sign)))    
    (define (ones-digit)
      (define (o-helper x)
        (car (reverse x)))
      (o-helper x))
    (define (is-zero?)
      (define (z-helper x)
        (if (= 0 (car x))
            #t
            #f))
      (z-helper x))
    (define (positive?)
      (define (p-helper sign)
        (if (equal? sign #t)
            #t
            #f))
      (p-helper sign))
    (lambda (method)
      (cond ((eq? method 'increment) increment)
            ((eq? method 'decrement) decrement)
            ((eq? method 'power-up) power-up)
            ((eq? method 'power-down) power-down)
            ((eq? method 'ones-digit) ones-digit)
            ((eq? method 'is-zero?) is-zero?)
            ((eq? method 'positive?) positive?)))))
(define my-number (object))

;2)
(define (first str) (car str))
(define (rest str) ((cdr str)))
(define (fib-stream current next)
  (cons current (lambda () 
                  (fib-stream next (+ current next)))))
(define (squares-stream a)
  (cons (* a a) (lambda () (squares-stream (+ a 1)))))
(define (cubes-stream a)
  (cons (* a a a) (lambda () (cubes-stream (+ a 1)))))


(define (merge s t)
  (cond ((null? s) t)
        ((null? t) s)
        (else 
         (cond ((< (first s) (first t))
                (cons (first s) (lambda () (merge (rest s) t))))
               (else
                (cons (first t) (lambda () (merge s (rest t)))))))))
(define m (merge (squares-stream 1) (cubes-stream 1)))
m
(rest m)
(rest (rest m))
(rest (rest (rest m)))
(rest (rest (rest (rest m))))
(rest (rest (rest (rest (rest m)))))
(rest (rest (rest (rest (rest (rest m))))))
(rest (rest (rest (rest (rest (rest (rest m)))))))
(rest (rest (rest (rest (rest (rest (rest (rest m))))))))
(newline)

;3) using the squares and cubes example, 1 and 36 are not repeated
(define (merge-updated s t)
  (cond ((null? s) t)
        ((null? t) s)
        (else 
         (cond ((< (first s) (first t))
                (cons (first s) (lambda () (merge (rest s) t))))
               ((> (first s) (first t))
                (cons (first t) (lambda () (merge s (rest t)))))
               (else
                (cons (first t) (lambda () (merge (rest s) (rest t)))))))))
(define m-updated (merge-updated (squares-stream 1) (cubes-stream 1)))
m-updated
(rest m-updated)
(rest (rest m-updated))
(rest (rest (rest m-updated)))
(rest (rest (rest (rest m-updated))))
(rest (rest (rest (rest (rest m-updated)))))
(rest (rest (rest (rest (rest (rest m-updated))))))
(rest (rest (rest (rest (rest (rest (rest m-updated)))))))
(rest (rest (rest (rest (rest (rest (rest (rest m-updated))))))))
(newline)

;4)
(define (stream-zip s t)
  (cons (cons (first s) (first t))
        (lambda () (stream-zip (rest s) (rest t)))))
(define zip (stream-zip (squares-stream 1) (cubes-stream 1)))
zip
(rest zip)
(rest (rest zip))
(rest (rest (rest zip)))
(rest (rest (rest (rest zip))))
(rest (rest (rest (rest (rest zip)))))
(newline)

;5.a)
(define (c-add pair1 pair2)
  (cond ((null? pair1) pair2)
        ((null? pair2) pair1)
        (else
         (cons (+ (car pair1) (car pair2)) (+ (cdr pair1) (cdr pair2))))))
(c-add (cons 3 5) (cons 2 -9))
(newline)

(define (c-multiply pair1 pair2)
  (cond ((null? pair1) pair2)
        ((null? pair2) pair1)
        (else
         (cons (- (* (car pair1) (car pair2)) (* (cdr pair1) (cdr pair2)))
               (+ (* (car pair1) (cdr pair2)) (* (cdr pair1) (car pair2)))))))
(c-multiply (cons 5 1) (cons 3 0))
(newline)

(define (c-length pair)
  (sqrt (+ (expt (car pair) 2) (expt (cdr pair) 2))))
(c-length (cons 3 4))
(newline)

;5.b)
(define (value z y) (c-add (c-multiply y y) z))
(define (mandelbrot z)
  (define (helper-mandelbrot z a)
    (cons a (lambda () (helper-mandelbrot 
                        (c-add (c-multiply a a) z)
                        z))))
  (helper-mandelbrot z (cons 0 0)))
(define m-stream (mandelbrot (cons 1 1)))
(newline)

;5.c)
(define (map-stream f stream)
  (if (null? stream)
      '()
      (cons (f (first stream)) (map-stream f (rest stream)))))

(define (mandelbrot-l z)
  (define (helper z a)
  (stream-map (+ (* z z) a) (mandelbrot z)))
  (helper z 0))

;5.d)
(define (depth z max)
(define (helper max z counter)
  (define z′ (+ (* z z) max))
  (if (or (= counter 255) (> (magnitude z′) 2))
      counter
      (helper max z′ (+ 1 counter))))
  (helper max z 0))

(define (iter->color i)
  (if (= i 255)
      (make-object color% "black")
      (make-object color% (* 5 (modulo i 15))
        (* 32 (modulo i 7))
        (* 8 (modulo i 31)))))
(define (mandelbrot-g width height) 
  (define target (make-bitmap width height))
  (define dc (new bitmap-dc% [bitmap target]))
  (for* ([x width] [y height])
    (define real-x (- (* 3.0 (/ x width)) 2.25))
    (define real-y (- (* 2.5 (/ y height)) 1.25))
    (send dc set-pen (iter->color (depth (make-rectangular real-x real-y)
                                         0))
          1 'solid)
    (send dc draw-point x y))
  (send target save-file "mandelbrot.png" 'png))
(mandelbrot-g 300 200)