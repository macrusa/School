(define (make-leaf symbol weight) (list 'internal symbol weight))
(define (internal? object) (eq? (car object) 'internal))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
        right 
        (append (symbols left) (symbols right))
        (+ (weight left)
           (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (internal? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree) 
  (if (internal? tree)
      (weight-leaf tree)
      (cadddr tree)))

;1)
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set)))
         (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)
                               (cadr pair))
                    (make-leaf-set (cdr pairs))))))
(define (generate-huffman-tree pairs)
  (define (successive-merge tree)
  (if (null? (cdr tree))
      (car tree)
      (let ((node-1 (car tree))
            (node-2 (cadr tree))
            (rest (cddr tree)))
        (let ((new-node (make-code-tree node-1 node-2)))
          (successive-merge (adjoin-set new-node rest))))))
  (successive-merge (make-leaf-set pairs)))
(generate-huffman-tree '((#\a 2013) (#\b 507) (#\c 711)))

(define (remove pair1 pair2 lst)
  (define (remove pair lst)
    (cond ((null? lst) '())
          ((eq? (car pair) (car (car lst))) (cdr lst))
          (else (cons (car lst) (remove pair (cdr lst))))))
  (remove pair2 (remove pair1 lst)))
(define (order-pairs pairs)
    (define (adjoin-set x set)
      (cond ((null? set) (list x))
            ((< (cdr x) (cdr (car set))) (cons x set))
            (else (cons (car set) (adjoin-set x (cdr set))))))
    (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (cons (car pair) (cdr pair))
                    (order-pairs (cdr pairs))))))
  
(define (construct-tree pairs)
  (cond ((null? pairs) '())
        ((null? (cdr (cdr pairs)))
         (cons (make-leaf (car (car (order-pairs pairs)))
                          (car (car (cdr (order-pairs pairs)))))
            (+ (cdr (car (order-pairs pairs)))
                     (cdr (car (cdr (order-pairs pairs)))))))
      (else (let ((L (cons (make-leaf (car (car (order-pairs pairs)))
                                (car (car (cdr (order-pairs pairs)))))
            (+ (cdr (car (order-pairs pairs)))
                     (cdr (car (cdr (order-pairs pairs))))))))
          (begin (set! pairs (append (list L)
                                     (remove (car (order-pairs pairs))
                                             (car (cdr (order-pairs pairs)))
                                               pairs)))
                   (construct-tree pairs))))))
(construct-tree (list (cons #\a 2013) (cons #\b 507) (cons #\c 711)))

;2)
(define sample-tree
  (make-code-tree (make-leaf '#\A 4)
                  (make-code-tree
                   (make-leaf '#\B 2)
                   (make-code-tree (make-leaf '#\D 1)
                                   (make-leaf '#\C 1)))))
(define (en tree)
(define (encode element tree)
(define (encode-symbol symbol tree)
  (cond ((internal? tree) '())
        ((member symbol (symbols (left-branch tree)))
         (cons 0 (encode-symbol symbol (left-branch tree))))
        ((member symbol (symbols (right-branch tree)))
         (cons 1 (encode-symbol symbol (right-branch tree))))))
(if (or (null? tree) (null? element))
      '()
      (append (cons (cons (car element) (encode-symbol (car element) tree))
              (encode (cdr element) tree)))))
  (encode (symbols tree) tree))
(en sample-tree)
           
;3)
(define (encode message tree)
(define (encode-symbol symbol tree)
  (cond ((internal? tree) '())
        ((member symbol (symbols (left-branch tree)))
         (cons 0 (encode-symbol symbol (left-branch tree))))
        ((member symbol (symbols (right-branch tree)))
         (cons 1 (encode-symbol symbol (right-branch tree))))))
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
(encode (list #\A #\B #\C) sample-tree)

;4)
(define (decode-huff bits tree)
  (define (choose-branch bit branch)
    (cond ((= bit 0) (left-branch branch))
          ((= bit 1) (right-branch branch))
          (else ("bad bit" bit))))
  (define (helper bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (internal? next-branch)
              (cons (symbol-leaf next-branch)
                    (helper (cdr bits) tree))
              (helper (cdr bits) next-branch)))))
  (list->string (helper bits tree)))
  
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(decode-huff sample-message sample-tree)

;5)
(define (h-code-object)
  (let ((tree sample-tree))
    (define (code message)
      (encode message tree))
  (define (decode bits)
    (decode-huff bits tree))
  (lambda (method)
    (cond ((eq? method 'code) code)
          ((eq? method 'decode) decode)))))
(define my-tree (h-code-object))
((my-tree 'decode) (list 0 1 1 0 0 1 0 1 0 1 1 1 0))
((my-tree 'code) (list #\A #\B #\C))