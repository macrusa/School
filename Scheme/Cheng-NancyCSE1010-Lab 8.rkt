;1)
(define (num-occurs c L)
  (define (helper L counter)
    (cond ((null? L) counter)
          ((equal? (car L) c) (helper (cdr L) (+ counter 1)))
          (else (helper (cdr L) counter))))
  (helper L 0))
(num-occurs #\e '(#\S #\c #\h #\e #\m #\e))

;2)
(define (value T) (car T))
(define (left T) (cadr T))
(define (right T) (caddr T))
(define (make-tree value left right)
  (list value left right))
(define (insert x T)
  (cond ((null? T) (make-tree x '() '()))
        ((equal? x (value T)) T)
        ((char<? x (value T)) (make-tree (value T)
                                         (insert x (left T))
                                         (right T)))
        ((char>? x (value T)) (make-tree (value T)
                                         (left T) 
                                         (insert x (right T))))))
(define (insert-all L T)
  (if (null? L)
      T
      (insert-all (cdr L) (insert (car L) T))))
(define (extract-all T)
  (define (extract-to T L)
    (if (null? T)
        L
        (cons (value T)
              (extract-to (left T)
                          (extract-to (right T) L)))))
  (extract-to T (list)))

(define (freq-list L)
  (define (extract-alphabet L)
    (extract-all (insert-all L '())))
  (define (freq-aux L unique-lst)
    (cond ((null? unique-lst) '())
          (else (cons (cons (car unique-lst) (num-occurs (car unique-lst) L)) (freq-aux L (cdr unique-lst))))))
  (if (null? L)
      '()
       (freq-aux L (extract-alphabet L))))
(freq-list '(#\S #\c #\h #\e #\m #\e))

;3)
(define (h-max h) (car h))
(define (left h) (cadr h))
(define (right h) (caddr h))
(define (create-heap h-max left right) (list h-max left right))

(define (insert-pair pair h)
  (cond ((null? h) (create-heap pair '() '()))
        ((> (cdr pair) (cdr (h-max h)))
         (create-heap pair (right h) (insert-pair (h-max h) (left h))))
        (else 
         (create-heap (h-max h) (right h) (insert-pair pair (left h))))))
(insert-pair (cons #\a 4) (create-heap (cons #\e 9) (list (cons #\f 2) '() '()) (list (cons #\q 1) '() '())))

(define (insert-list L h)
  (if (null? L)
      h
      (insert-list (cdr L) (insert-pair (car L) h))))
(insert-list (list (cons #\a 9) (cons #\e 7)) (create-heap (cons #\e 9) '() '()))

(define (extract-most h)
  (define (remove-top h)
    (cond ((null? h) '())
           ((null? (left h)) (right h))
           ((null? (right h)) (left h))
           ((> (cdr (h-max (left h))) (cdr (h-max (right h))))
            (create-heap (h-max (left h)) (remove-top (left h)) (right h)))
           (else
            (create-heap (h-max (right h)) (left h) (remove-top (right h))))))
  (if (null? h) '()
      (cons (car (h-max h)) (remove-top h))))
(extract-most (create-heap (cons #\a 9) (list (cons #\s 4) '() '()) (list (cons #\j 1) '() '())))


;4)
(define L (string->list "Computer sccccccccccccccccccccccccciiiiiiiiiiieeeence is a challenging course"))
(car (extract-most (insert-list (freq-list L) '())))
(define heap2 (cdr (extract-most (insert-list (freq-list L) '()))))
(car (extract-most heap2))
(define heap3 (cdr (extract-most heap2)))
(car (extract-most heap3))

(define first-step
  (extract-most (insert-list (freq-list L) '())))
(car first-step)
(define second-step
  (extract-most (cdr first-step)))
(car second-step)
(define third-step (extract-most (cdr second-step)))
(car third-step)
