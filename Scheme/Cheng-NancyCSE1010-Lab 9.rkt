;1)
(define (factorial n)
  (define i 1)
  (define prod 1)
  (define (helper)
    (if (> i n)
        prod
    (begin (set! prod (* prod i))
           (set! i (+ 1 i))
           (helper))))
  (helper))
(factorial 7)

;2)
(define (hailstone n)
  (define (helper)
    (display n)
    (newline)
    (if (= n 1)
        "terminate"
        (if (even? n)
            (begin (set! n (/ n 2))
                   (helper))
            (begin (set! n (+ 1 (* 3 n)))
                   (helper)))))
  (helper))
(hailstone 7)

;3) able to alter the initial-balance b/c have parameter
(define (new-account initial-balance)
  (let ((balance initial-balance)
        (interest 0.01))
    (define (deposit f)
      (begin (set! balance (+ balance f))
             balance))
    (define (withdraw f)
      (begin (set! balance (- balance f))
             balance))
    (define (bal-inq) balance)
    (define (accure)
      (begin (set! balance (* balance (+ 1 interest)))
             balance))
    (define (setrate rate)
      (set! interest rate))
    (lambda (method)
      (cond ((eq? method 'deposit) deposit)
            ((eq? method 'withdraw) withdraw)
            ((eq? method 'balance-inquire) bal-inq)
            ((eq? method 'accure) accure)
            ((eq? method 'inerest) interest)
            ((eq? method 'setrate) setrate)))))

;4)acct1 and acct2 are separate because they have 103 and 1050 as with their different rates
(define my-acct1 (new-account 100))
;I am able to change the rate to 0.03
((my-acct1 'setrate) 0.03)
;When I output the originally set 0.01% interest, it is 0.03 because my bank account modifies the interst rate independently
((my-acct1 'accure))
(define my-acct2 (new-account 1000))
((my-acct2 'setrate) 0.05)
((my-acct2 'accure))

;5) initial value is '()
(define (make-tree value left right) (list value left right))
(define (value t) (car t))
(define (left t) (cadr t))
(define (right t) (caddr t))
(define (set-tree)
  (let ((t '()))
    (define (element? x)
      (define (helper t)
        (cond ((null? t) #f)
              ((= x (value t)) #t)
              ((if (> x (value t))
                   (helper (right t))
                   (helper (left t))))
              (else #f)))
      (helper t))
    (define (insert x)
      (define (helper t)
        (cond ((null? t) (make-tree x '() '()))
              ((= x (value t)) t)
              ((> x (value t))
               (make-tree (value t) (left t) (helper (right t))))
              (else
               (make-tree (value t) (helper (left t)) (right t)))))
      (set! t (helper t))
      t)
    ;(set t (helper t)) t) or (set t (helper t)) (helper t))
    (define (extract-sorted)
      (define (helper t)
        (if (null? t)
            '()
            (append (helper (left t))
                    (list (value t))
                    (helper (right t)))))
      (helper t))
    (lambda (method)
      (cond ((eq? method 'element?) element?)
            ((eq? method 'insert) insert)
            ((eq? method 'extract-sorted) extract-sorted)))))
(define my-tree (set-tree))
((my-tree 'element?) 5)
((my-tree 'insert) 9)
((my-tree 'insert) 7)
((my-tree 'insert) 2)
((my-tree 'extract-sorted))